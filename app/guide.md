### Insert Date String extension ctrl + shift + i <hr>
### sudo code /home/feelsever/laravelapp/ --user-data-dir /home/feelsever/ <hr>
### #TODO - флаг что не изучил до конца.
<hr><hr><hr>

# Day 1 ----------------------------------------
_2020-01-15 23:30:54_

### Отношения Eloquent 
Теперь, когда наши модели определены, нам нужно связать их. Например, наш User может иметь несколько Task, в то время как Task привязан к единственному User. Определение взаимосвязи позволит нам быстро проходить через наши отношения: 

<pre>
$user = App\User::find(1);

foreach ($user->tasks as $task) {
  echo $task->name;
}
</pre>

# Day 2 ----------------------------------------
_2020-01-16 22:18:47_

## Один к одному

Связь вида «один к одному» является очень простой. К примеру, модель User может иметь один Phone. Чтобы определить такое отношение, мы помещаем метод phone() в модель User. Метод phone() должен вызвать метод hasOne() и вернуть его результат
<pre>
public function phone()
{
  return $this->hasOne('App\Phone');
}
</pre>

 Первый параметр, передаваемый hasOne(), — имя связанной модели. Как только отношение установлено, вы можете получить к нему доступ через динамические свойства Eloquent. Динамические свойства позволяют вам получить доступ к функциям отношений, если бы они были свойствами модели:

<pre>
$phone = User::find(1)->phone;
</pre>
  
 Eloquent определяет внешний ключ отношения по имени модели. В данном случае предполагается, что это user_id. Если вы хотите перекрыть стандартное имя, передайте второй параметр методу hasOne(). Кроме того вы можете передать в метод третий аргумент, чтобы указать свой столбец для объединения
 
<pre>
return $this->hasOne('App\Phone', 'foreign_key', 'local_key'); </pre>

## Создание обратного отношения
Итак, у нас есть доступ к модели Phone из нашего User. Теперь давайте определим отношение для модели Phone, которое будет иметь доступ к User, владеющего этим телефоном. Для создания обратного отношения в модели Phone используйте метод belongsTo()

<pre>

Получить пользователя, владеющего данным телефоном.

public function user()
{
  return $this->belongsTo('App\User');
}
</pre>

Если имя внешнего ключа модели Phone не user_id, передайте это имя вторым параметром в метод belongsTo

Если ваша родительская модель не использует id в качестве первичного ключа, или вам бы хотелось присоединить дочернюю модель к другому столбцу, вы можете передать третий параметр в метод belongsTo(), который определяет имя связанного столбца в родительской таблице
<pre>

Получить пользователя, владеющего данным телефоном.

public function user()
{
  return $this->belongsTo('App\User', 'foreign_key', 'other_key');
}
</pre>


## Один ко многим

Примером отношения «один ко многим» является статья в блоге, которая имеет «много» комментариев. Как и другие отношения Eloquent вы можете смоделировать это отношение таким образом

<pre>

Получить комментарии статьи блога

class Post extends Model
{
  public function comments()
  {
    return $this->hasMany('App\Comment');
  }
}
</pre>

Помните, что Eloquent автоматически определяет столбец внешнего ключа в модели Comment. По соглашению, Eloquent возьмёт «snake case» названия владеющей модели плюс _id. Таким образом, для данного примера, Eloquent предполагает, что внешним ключом для модели Comment будет post_id. 

После определения отношения мы можем получить доступ к коллекции комментариев, обратившись к свойству comments. Помните, что поскольку Eloquent поддерживает «динамические свойства», мы можем обращаться к функциям отношений, как если бы они были определены свойством модели

<pre>
$comments = App\Post::find(1)->comments;
</pre>

Конечно, так как отношения служат и в качестве конструкторов запросов, вы можете добавлять дополнительные условия к тем комментариям, которые получены вызовом метода

<pre>
$comments = App\Post::find(1)->comments()->where('title', 'foo')->first();
</pre>

Как и для метода hasOne() вы можете указать внешний и локальный ключи, передав дополнительные параметры в метод hasMany()

## Один ко многим (Обратное отношение)

После получения доступа ко всем комментариям статьи давай определим отношение, которое позволит комментарию получить доступ к его статье. Чтобы определить обратное отношение hasMany(), давайте определим функцию отношения на дочерней модели, которая вызывает метод belongsTo()
<pre>
class Comment extends Model
{

  Получить статью данного комментария.
  
  public function post()
  {
    return $this->belongsTo('App\Post');
  }
}

После определения отношений мы можем получить модель Post для Comment, обратившись к динамическому свойству post

$comment = App\Comment::find(1);

echo $comment->post->title;
</pre>

## Многие ко многим

Отношения типа «многие ко многим» сложнее отношений hasOne() и hasMany(). Примером может служить пользователь, имеющий много ролей, где роли также относятся ко многим пользователям. Например, несколько пользователей могут иметь роль «Admin». Нужны три таблицы для этой связи: users, roles и role_user. Имя таблицы role_user получается из упорядоченных по алфавиту имён связанных моделей, она должна иметь поля user_id и role_id

Вы можете определить отношение «многие ко многим», написав метод, возвращающий результат метода belongsToMany(). Давайте определим метод roles() для модели User

<pre>
class User extends Model
{

  Роли, принадлежащие пользователю

  public function roles()
  {
    return $this->belongsToMany('App\Role');
  }
}

Теперь мы можем получить роли пользователя через динамическое свойство roles:

$user = App\User::find(1);

Естественно, как и для других типов отношений, вы можете вызвать метод roles(), продолжив конструировать запрос для отношения:
PHP

$roles = App\User::find(1)->roles()->orderBy('name')->get();
</pre>
Чтобы определить обратное отношение «многие-ко-многим», просто поместите другой вызов belongsToMany() на вашу модель

## Получение промежуточных столбцов таблицы 

Работа с отношением «многие-ко-многим» требует наличия промежуточной таблицы. Eloquent предоставляет некоторые очень полезные способы взаимодействия с такой таблицей. Например, давайте предположим, что наш объект User имеет много связанных с ним объектов Role. После получения доступа к этому отношению мы можем получить доступ к промежуточной таблице с помощью pivot атрибута модели

<pre>

$user = App\User::find(1);

foreach ($user->roles as $role) {
  echo $role->pivot->created_at;
}
</pre>

Обратите внимание на то, что каждой полученной модели Role автоматически присваивается атрибут pivot. Этот атрибут содержит модель, представляющую промежуточную таблицу, и может быть использован, как и любая другая модель Eloquent.

По умолчанию, только ключи модели будут представлять pivot объект. Если ваша «pivot» таблица содержит дополнительные атрибуты, вам необходимо указать их при определении отношения:
<pre>
return $this->belongsToMany('App\Role')->withPivot('column1', 'column2');
</pre>

Если вы хотите, чтобы ваша «pivot» таблица автоматически поддерживала временные метки created_at и updated_at, используйте метод withTimestamps() при определении отношений:

<pre>
return $this->belongsToMany('App\Role')->withTimestamps();
</pre>

# Day 3 ----------------------------------------

_2020-01-18 18:38:03_

Присутствуют еще связь "Ко многим через" и "Полиморфные отношения", рассматривать пока не буду. #TODO - https://laravel.ru/docs/v5/eloquent-relationships#hmt



## Продолжаю выполнять основной гайд

Мы определим функцию tasks в модели User, которая вызывает Eloquent-метод hasMany.
<pre>
public function tasks()
  {
    return $this->hasMany(Task::class);
  }
</pre>

## Аутентификация

app/Http/Controllers/Auth/AuthController уже включён в приложение Laravel. Этот контроллер использует специальный типаж (trait) AuthenticatesAndRegistersUsers со всей необходимой логикой для создания и аутентификации пользователей

Нам нужно создать шаблоны регистрации и входа в систему, а также определить маршруты, указывающие на контроллер аутентификации.

 Мы можем сделать это с помощью Artisan-команды make:auth: 

<pre>
php artisan make:auth
</pre>

> Уточнение для laravel 6+:
>> В Laravel 6+ команда make:auth больше не существует.
>> Необходимо установить laravel/ui модуль через Composer:
>> <pre>
>> composer require laravel/ui
>>    и использовать
>> php artisan ui:auth

>> https://stackoverflow.com/questions/34545641/php-artisan-makeauth-command-is-not-defined
>></pre>

# Day 4 ----------------------------------------

_2020-01-19 16:44:43_

После добавления файлов с аутентификацией обнаружилась проблема с подгрузкой ассетов из шаблонов. 

Проблема была решена с помощью npm: 
<pre>
#TODO: понять почему
npm run dev
</pre>

_2020-01-19 18:21:03_

#WHATWASDO: пришёл ssl-ключ для домена. Настроил ssl и переадресацию на https

# Day 5 ----------------------------------------

_2020-01-21 22:29:59_

Поскольку мы знаем, что нам нужно получать и сохранять задачи, давайте создадим TaskController с помощью командной строки Artisan, при этом новый контроллер будет помещён в папку app/Http/Controllers: 

<pre>
php artisan make:controller TaskController
</pre>

Теперь, когда контроллер создан, давайте создадим стабы для некоторых маршрутов в нашем файле app/Http/routes.php, указывающих на контроллер: 

<pre>
Route::get('/tasks', 'TaskController@index');
Route::post('/task', 'TaskController@store');
Route::delete('/task/{task}', 'TaskController@destroy');
</pre>

_2020-01-21 23:10:29_